#include<stdio.h>
#include<stdlib.h>

#define N 10
#define TRUE 1
#define FALSE 0
#define INF 1000

typedef char element;
element visited[N] = { 0 };

typedef struct Edge {
	element v1, v2;
	int weight;
	struct Edge* next;
}Edge;

typedef struct Vertex {
	element vName;
	int isVisit;
	struct AdjacentVertex* aHead;
	struct Vertex* next;
}Vertex;

typedef struct AdjacentVertex {
	element aName;
	Edge* e;
	struct AdjacentVertex* next;
}AdjacentVertex;

typedef struct {
	Vertex* vHead;
	Edge* eHead;
	int vCount, eCount; // 정점 개수, 간선 개수
}GraphType;

void initGraph(GraphType* G) {
	G->vHead = NULL;
	G->eHead = NULL;
	G->vCount = G->eCount = 0;
}

void makeVertax(GraphType* G, element vName) {
	Vertex* v = (Vertex*)malloc(sizeof(Vertex));
	v->vName = vName;
	v->isVisit = FALSE;
	v->aHead = NULL;
	v->next = NULL;

	G->vCount++;

	Vertex* p = G->vHead;

	if (p == NULL) { // 그래프에 정점이 없다
		G->vHead = v;
	}
	else { // 비어 있지 않으면 맨 뒤로 가서 붙어야함
		while (p->next != NULL) {
			p = p->next;
		}
		p->next = v;
	}
}

void printGraph(GraphType* G) {
	Vertex* v = NULL;
	AdjacentVertex* a = NULL;

	for (v = G->vHead; v != NULL; v = v->next) {
		printf("[%c]  ", v->vName);
		for (a = v->aHead; a != NULL; a = a->next) {
			printf("[%c, %d]   ", a->aName,a->e->weight);
		}
		printf("\n");
	}
}

Vertex* findVertex(GraphType* G, element vName) {
	Vertex* p = G->vHead;

	while (p->vName != vName) {
		p = p->next;
	}
	return p;
}

void makeAdjacentVertex(Vertex* v, element aName,Edge* e) {
	AdjacentVertex* a = (AdjacentVertex*)malloc(sizeof(AdjacentVertex));
	a->aName = aName;
	a->e = e;
	a->next = NULL;

	AdjacentVertex* p = v->aHead;

	if (p == NULL) {
		v->aHead = a;
	}
	else {
		while (p->next != NULL) {
			p = p->next;
		}
		p->next = a;
	}
}

void insertEdge(GraphType* G, element v1, element v2, int weight) {
	Edge* e = (Edge*)malloc(sizeof(Edge));
	e->v1 = v1;
	e->v2 = v2;
	e->weight = weight;
	e->next = NULL;

	G->eCount++;

	Edge* p = G->eHead;

	if (p == NULL) {
		G->eHead = e;
	}
	else {
		while (p->next != NULL) {
			p = p->next;
		}
		p->next = e;
	}
	Vertex* v = findVertex(G, v1);
	makeAdjacentVertex(v, v2, e);

	v = findVertex(G, v2);
	makeAdjacentVertex(v, v1, e);
}

void incSort(GraphType* G, Edge* edges[]) {
	int i, least;
	Edge* p = G->eHead;

	for (i = 0; i < G->eCount; i++) {
		edges[i] = p; // 가중치 신경 안쓰고 일단 배열에다가 넣어 
		p = p->next; 
	}
	for (i = 0; i < G->eCount - 1; i++) { // 바깥 루프는 간선-1 만큼만 돌아 -> 이미 최솟값 정렬 끝남
		least = i; // 최솟값을 가지는 인덱스 설정
		for (int j = i + 1; j < G->eCount; j++) { // i 다음칸부터 끝까지 돌아
			if (edges[j]->weight < edges[least]->weight) {
				least = j;
			}
		}
		p = edges[least];
		edges[least] = edges[i];
		edges[i] = p;
	} // 정렬 끝!

	for (i = 0; i < G->eCount; i++) {
		printf("[%c%c%d] ", edges[i]->v1, edges[i]->v2, edges[i]->weight);
	}
}
