#include<stdio.h>
#include<stdlib.h>

#define N 10
#define TRUE 1
#define FALSE 0
#define INF 1000

typedef char element;
element visited[N] = { 0 };

typedef struct Edge {
	element v1, v2;
	int weight;
	struct Edge* next;
}Edge;

typedef struct Vertex {
	element vName;
	int isVisit;
	struct AdjacentVertex* aHead;
	struct Vertex* next;
}Vertex;

typedef struct AdjacentVertex {
	element aName;
	Edge* e;
	struct AdjacentVertex* next;
}AdjacentVertex;

typedef struct {
	Vertex* vHead;
	Edge* eHead;
	int vCount, eCount; // 정점 개수, 간선 개수
}GraphType;

void initGraph(GraphType* G) {
	G->vHead = NULL;
	G->eHead = NULL;
	G->vCount = G->eCount = 0;
}

void makeVertax(GraphType* G, element vName) {
	Vertex* v = (Vertex*)malloc(sizeof(Vertex));
	v->vName = vName;
	v->isVisit = FALSE;
	v->aHead = NULL;
	v->next = NULL;

	G->vCount++;

	Vertex* p = G->vHead;

	if (p == NULL) { // 그래프에 정점이 없다
		G->vHead = v;
	}
	else { // 비어 있지 않으면 맨 뒤로 가서 붙어야함
		while (p->next != NULL) {
			p = p->next;
		}
		p->next = v;
	}
}

void printGraph(GraphType* G) {
	Vertex* v = NULL;
	AdjacentVertex* a = NULL;

	for (v = G->vHead; v != NULL; v = v->next) {
		printf("[%c]  ", v->vName);
		for (a = v->aHead; a != NULL; a = a->next) {
			printf("[%c, %d]   ", a->aName,a->e->weight);
		}
		printf("\n");
	}
}

Vertex* findVertex(GraphType* G, element vName) {
	Vertex* p = G->vHead;

	while (p->vName != vName) {
		p = p->next;
	}
	return p;
}

void makeAdjacentVertex(Vertex* v, element aName,Edge* e) {
	AdjacentVertex* a = (AdjacentVertex*)malloc(sizeof(AdjacentVertex));
	a->aName = aName;
	a->e = e;
	a->next = NULL;

	AdjacentVertex* p = v->aHead;

	if (p == NULL) {
		v->aHead = a;
	}
	else {
		while (p->next != NULL) {
			p = p->next;
		}
		p->next = a;
	}
}

void insertEdge(GraphType* G, element v1, element v2, int weight) {
	Edge* e = (Edge*)malloc(sizeof(Edge));
	e->v1 = v1;
	e->v2 = v2;
	e->weight = weight;
	e->next = NULL;

	G->eCount++;

	Edge* p = G->eHead;

	if (p == NULL) {
		G->eHead = e;
	}
	else {
		while (p->next != NULL) {
			p = p->next;
		}
		p->next = e;
	}
	Vertex* v = findVertex(G, v1);
	makeAdjacentVertex(v, v2, e);

	v = findVertex(G, v2);
	makeAdjacentVertex(v, v1, e);
}

void incSort(GraphType* G, Edge* edges[]) {
	int i, least;
	Edge* p = G->eHead;

	for (i = 0; i < G->eCount; i++) {
		edges[i] = p; // 가중치 신경 안쓰고 일단 배열에다가 넣어 
		p = p->next; 
	}
	for (i = 0; i < G->eCount - 1; i++) { // 바깥 루프는 간선-1 만큼만 돌아 -> 이미 최솟값 정렬 끝남
		least = i; // 최솟값을 가지는 인덱스 설정
		for (int j = i + 1; j < G->eCount; j++) { // i 다음칸부터 끝까지 돌아
			if (edges[j]->weight < edges[least]->weight) {
				least = j;
			}
		}
		p = edges[least];
		edges[least] = edges[i];
		edges[i] = p;
	} // 정렬 끝!

	for (i = 0; i < G->eCount; i++) {
		printf("[%c%c%d] ", edges[i]->v1, edges[i]->v2, edges[i]->weight);
	}
}

int vFind(int vertices[], int vNum) {
	if (vertices[vNum] == -1) {
		return vNum;
	}
	while (vertices[vNum] != -1) {
		vNum=vertices[vNum]; // 같은 집합에 있는 정점으로 가라. 긍까 b(1)가 -1 c(2)가 1, g가 2인데 내가 g을 보냈으면 g->c->b로 이동해서 -1을 찾음

		return vNum; // 그때 vNum 돌려줌
	}
}

void vUnion(int vertices[], int vNum1, int vNum2) {
	vertices[vNum2] = vNum1;
}

void kruskal(GraphType* G, Edge* edges[], int vertices[]) {
	int eCnt = 0; int i = 0;

	int vNum1, vNum2;
	Edge* p;
	
	while (eCnt < G->vCount - 1) {
		p = edges[i];
		vNum1 = vFind(vertices, p->v1 - 97); // 캐릭터를 인트로 해주려고 -97
		vNum2 = vFind(vertices, p->v2 - 97);

		if (vNum1 != vNum2) {
			eCnt++;
			printf("%d. [%c%c %d]\n", eCnt, p->v1, p->v2, p->weight);
			vUnion(vertices, vNum1, vNum2);
		}
		i++;
	}
}

element getMinVertex(GraphType* G, int dist[]) { // 최소 경로를 찾아 반환하는 함수
	Vertex* v = NULL;
	element name;

	for (v = G->vHead; v != NULL; v = v->next) {
		if (v->isVisit == FALSE) {
			name = v->vName; // 방문 안한 정점의 이름을 vName에다가 넣어줌
			break;
		}
	}
	for (v = G->vHead; v != NULL; v = v->next) {
		if ((v->isVisit == FALSE) && (dist[v->vName - 97] < dist[name - 97])) {
			name = v->vName;
		}
	}
	return name; // 방문하지 않은 정점 중 가장 가까운 정점을 돌려줌
}

void prim(GraphType* G, element vName, int dist[]) {
	Vertex* v = findVertex(G, vName);
	AdjacentVertex* a = NULL;
	element name;

	dist[vName - 97] = 0; // 시작 정점을 0으로
	
	for (int i = 0; i < G->vCount; i++) {
		name = getMinVertex(G, dist);
		v = findVertex(G, name);
		v->isVisit = TRUE;
		printf("[%c] ", v->vName);

		for (a = v->aHead; a != NULL; a = a->next) { // 방문 정점의 인접정점 구경
			v = findVertex(G, a->aName); // 인접정점의 인접정점을 구경
			if (v->isVisit == FALSE && a->e->weight<dist[a->aName-97]) {
				dist[a->aName - 97] = a->e->weight;
			}
		}
	}
}

int main() {
	GraphType G;
	initGraph(&G);

	makeVertax(&G, 'a'); makeVertax(&G, 'b'); makeVertax(&G, 'c'); makeVertax(&G, 'd'); makeVertax(&G, 'e'); makeVertax(&G, 'f'); makeVertax(&G, 'g');

	insertEdge(&G, 'a', 'b',10); insertEdge(&G, 'a', 'g',3); insertEdge(&G, 'a', 'f', 7);
	insertEdge(&G, 'b', 'd',9); insertEdge(&G, 'b', 'g',6);
	insertEdge(&G, 'c', 'd',2); insertEdge(&G, 'c', 'g', 4);
	insertEdge(&G, 'd', 'g',10); insertEdge(&G, 'd', 'e', 4); insertEdge(&G, 'd', 'f',11);
	insertEdge(&G, 'e', 'f',5); 
	insertEdge(&G, 'f', 'g', 2);
	printGraph(&G);

	// Edge* edges[N]; printf("\n");
	// incSort(&G, edges); printf("\n");

	// int vertices[N] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	// kruskal(&G, edges, vertices); printf("\n");

    //int dist[N] = { INF,INF,INF,INF,INF,INF,INF,INF,INF,INF };
    // prim(&G, 'c', dist); printf("\n");
}