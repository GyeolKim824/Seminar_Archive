
// 문제 1
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define N 100

typedef struct StackType {
    int top;
    char stack[N];
} StackType;

void init(StackType* S) {
    S->top = -1;
}

int isFull(StackType* S) {
    return S->top == N - 1;
}

int isEmpty(StackType* S) {
    return S->top == -1;
}

void push(StackType* S, char c) {
    if (isFull(S)) {
        printf("Overflow!\n");
    }
    else {
        S->top++;
        S->stack[S->top] = c;
    }
}

char pop(StackType* S) {
    if (isEmpty(S)) {
        printf("Empty!\n");
        return -1;
    }

    char c = S->stack[S->top];
    S->top--;
    return c;
}

char peek(StackType* S) {
    if (isEmpty(S)) {
        printf("Empty!\n");
        return -1;
    }

    return S->stack[S->top];
}

void print(StackType* S) {
    for (int i = 0; i <= S->top; i++) {
        printf("%c  ", S->stack[i]);
    }
    printf("\n");
}

int prec(char op) {
    switch (op) {
    case '(': case ')':
        return 0;
    case '+': case '-':
        return 1;
    case '*': case '/':
        return 2;
    }
}

void convert(char infix[], char postfix[]) {
    StackType S;
    init(&S);

    char c, t;
    int n = strlen(infix);
    int j = 0;

    for (int i = 0; i < n; i++) {
        c = infix[i];

        switch (c) {
        case '+': case '-': case '*': case '/':
            while (!isEmpty(&S) && prec(c) <= prec(peek(&S))) {
                t = pop(&S);
                postfix[j++] = t;
                printf("%c", t); // 연산자를 출력
            }
            push(&S, c);
            break;
        case '(':
            push(&S, c);
            break;
        case ')':
            t = pop(&S);
            while (t != '(') {
                postfix[j++] = t;
                printf("%c", t); 
                t = pop(&S);
            }
            break;
        default:
            postfix[j++] = c;
            printf("%c", c);
            break;
        }
    }
    while (!isEmpty(&S)) {
        t = pop(&S);
        postfix[j++] = t;
        printf("%c", t); 
    }
    printf("\n");
}

char evaluate(char postfix[]) {
    StackType S;
    init(&S);

    int op1, op2, value;
    char c;
    int n = strlen(postfix);

    for (int i = 0; i < n; i++) {
        c = postfix[i];

        if (c != '+' && c != '-' && c != '*' && c != '/') {
            value = c - '0';
            push(&S, value);
        }
        else {
            op2 = pop(&S);
            op1 = pop(&S);
            switch (c) {
            case '+':
                push(&S, op1 + op2);
                break;
            case '-':
                push(&S, op1 - op2);
                break;
            case '*':
                push(&S, op1 * op2);
                break;
            case '/':
                push(&S, op1 / op2);
                break;
            }
        }
    }
    return pop(&S);
}

int main() {
    char infix[N], postfix[N];
    scanf("%s", infix);

    convert(infix, postfix);
    printf("%d\n", evaluate(postfix));
}

// 문제 2. 회문 판별

#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
#define N 100

typedef struct StackType {
	int top;
	char stack[N];
}StackType; void init(StackType* S) { // stack 초기화
	S->top = -1;
}

void push(StackType* S, char c) {
	if (isFull(S)) {
		printf("Overflow!\n");
	}
	else {
		S->top++;
		S->stack[S->top] = c;
	}
}

char pop(StackType* S) {
	if (isEmpty(S)) {
		printf("Empty!\n");
		return -1;
	}

	char c = S->stack[S->top];
	S->top--;
	return c;
}

int isFull(StackType* S) {
	return S->top == N - 1;
}

int isEmpty(StackType* S) {
    return S->top == -1;
}

int palin(char string[]) {
	StackType S;
	init(&S);

	int n = strlen(string);
	int m = n / 2;
	if (n % 2 != 0) {
		m++;
	}

	
	for (int i = 0; i < n; i++) {
		char c = string[i];
		push(&S, tolower(c));
	
	}

	for (int i = 0; i < m; i++) {
		char c = pop(&S);
		if (c != tolower(string[i])) {
			return 0;
		}
	}
	return 1;
}

int main() {
	char string[N];
	printf("단어를 입력하세요: ");
	scanf("%s", string);

	if (palin(string)) {
		printf("회문");
	}
	else {
		printf("회문이 아님");
	}
}